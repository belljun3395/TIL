# 2022-07-06

### Today I Learned

- 자바 객체 지향의 원리와 이해



## 객체 지향 설계 5원칙

---

SOLID는 아래 5가지 원칙의 앞 머리 알파벳을 따서 부르는 말이다.

- SRP : 단일 책임 원칙
- OCP : 개방 폐쇄 원칙
- LSP : 리스코프 치환 원칙
- ISP : 인터페이스 분리 원칙
- DIP : 의존 역전 원칙



이 원칙들은 응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립한 것이다.



> **결합도**는 모듈간의 상호 의존 정도를 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
>
> **응집도**는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정 유지보수가 용이하다.



### SRP - 단일 책임 원칙

---

어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다.



단일 책임 원칙은 "클래스는 단 한 개의 책임을 가져야 한다"를 의미하는 간단한 규칙이다.

클래스가 여러 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문에 클래스가 한 개의 책임만을 가져야 한다.

그렇기에 "클래스를 변경하는 이유"도 단 한개여야 한다.



책임의 개수가 많아질수록 한 책임의 기능 변화가 다른 책임에 주는 영향이 비례해서 증가한다.

즉, 코드를 절차 지향적이게 되어 유지 보수가 엉망이 된다.

단일 책임 원칙을 지키지 않았을 때의 다른 문제점은 재사용을 어렵게 한다는 것이다.



기능 변경 요구가 없을 때 수정에 대한 문제가 없다는 것을 보아 책임의 단위는 변화되는 부분과 관련이 있다.



우선 책임에 관한 의문을 알아보자

1. 클래스가 여러 가지의 (public) 메소드를 가진다면, 복수의 책임을 갖는가?
2. 클래스가 다중 상속을 한다면, 복수의 책임을 갖는가?
3. 해당 클래스를 의존하는 사용자가 여럿이라면 변경되는 이유는 여러가지가 되는가?



하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

'액터'는 시스템이 동일한 방식으로 변경되기를 원하는 사용자 집단을 의미한다.



위의 두 번째와 세 번째는 액터라는 개념을 통해 해결이 가능하다.

다중 상속을 받더라도 액터가 그 다중 상속한 것들을 모두 사용한다면 단일 책임 원칙을 만족하는 것이고, 해당 클래스의 사용자가 여러 명이어도 모두 동일한 요구 사항으로 해당 클래스를 사용한다면 단일 책임 원칙을 준수한다.



첫 번째 의문점도 마찬가지로 서로 다른 액터가 해당 클래스의 여러 가지 메소드를 사용하는 것이 아니라면, 복수의 메소드여도 단일 책임 원칙을 지키고 있는 것이다.



### OCP - 개방 폐쇄 원칙

---

소프트웨어 엔티티는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.



데이터베이스 프로그래밍이 개방 폐쇄 원칙의 아주 좋은 예이다.

JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없다.



개방 폐쇄 원칙의 핵심은 변화하는 부분을 추상화하는 것이다.

다른 방법은 상속을 이용하는 것이다.



추상화와 다형성을 이용해서 개방 폐쇄 원칙을 구현하기 때문에, 추상화와 다형성이 제대로 지켜지지 않은 코드는 개방 폐쇄 원칙을 어기게 된다.



OCP 원칙을 어기는 특징을 살펴보자.



1. 다운 캐스팅을 한다.
2. 비슷한 if ~ else 블록이 존재한다.



개방 폐쇄 원칙은 유연함에 관련된 원칙이다.

변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고도, 확장을 할 수 있게 만들어 준다.



### LSP - 리스코프 치환 원칙

---

서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.



상속에 대해 설명하면서 객체 지향에서 상속은 조직도나 계층도가 아닌 분류도가 돼야 한다.

객체 지향의 상속은 다음의 조건을 만족 한다.

- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류이다.
- 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.



하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역활을 하는데 문제가 없어야 한다.



리스코프 치환 원칙은 기능의 명세에 대한 내용이다.



리스코프 치환 원칙이 지켜지지 않으면 개방 폐쇄 원칙을 위반하게 되므로 기능 확장을 위해 더 많은 부분을 수정해야 한다.

이는 확장을 어렵게 한다.



### ISP - 인터페이스 분리 원칙

---

클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.



SRP(단일 책임 원칙)과 ISP(인터페이스 분활 원칙)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.

프로젝트 요구사항과 설계자의 취향에 따라 SRP나 ISP 중 하나를 선택해서 설계할 수 있다.

하지만 특별한 경우가 아니라면 SRP를 사용하는 것이 더 좋은 해결책이라 할 수 있다.



ISP를 이야기할 때 항상 함께 등장하는 원칙 중 하나가 인터페이스 최소주의 원칙이라는 것이 있다.

인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라는 것이다.

상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다고 했다.



인터페이스 분리 원칙은 클라이언트를 기준으로 인터페이스를 분리함으로써, 클라이언트로부터 발생하는 인터페이스의 여파가 다른 클라이언트에 미치는 영향을 최소화하는 것을 목표로 한다고 할 수 있다.



### DIP - 의존 역전 원칙

---

고차원 모듈은 저차원 모듈에 의존하면 안 된다.

이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.

추상화된 것은 구체적인 것에 의존하면 안 된다.

구체적인 것이 추상화된 것에 의존해야 한다.

자주 변경되는 구체 클래스에 의존하지 마라



의존 역전 원칙을 의역해 보면 다음과 같다.

자신보다 변하기 쉬운 것에 의존하지 마라



상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다.

