# 2022-06-18



## User, Record, Image model 구현

---

기본적인 구현이 끝나고난 이후 기획이 변경되어도 유지될 가능성이 큰 Model을 구현하기 시작하였다.



```js
// User Model

const { DataTypes, Sequelize } = require('sequelize');

module.exports = class User extends Sequelize.Model {
  static init(sequelize) {
    return super.init({
      name: {
        type: DataTypes.STRING(40),
        allowNull: true,
        validate : {
            name(value) {
                var isName =  /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/;
                if(isName.test(value) == false){
                    throw new Error('다시 이름을 입력해주세요!');
                }
            }
        }
      },
      sex: {
        type: DataTypes.STRING(40),
        allowNull: true,
        set(value) {
            this.setDataValue("sex", value.toLowerCase())
        },
        validate : {
            isIn : {
                args : [[ 'm', 'w' ]],
                msg : "성별을 다시 지정해 주세요"
            },
            sex(value) {
                var isSex = /[^m|w]/;
                if(isSex.test(value)) {
                    throw new Error('성별을 다시 지정해 주세요!')
                } else {
                    return console.log(value)
                }
            }
        }
      },
      cycle: {
        type: DataTypes.INTEGER(40),
        allowNull: true,
        validate: {
            isInt : true,
        }
      },
    }, {
      sequelize,
      timestamps: true,
      underscored: false,
      modelName: 'User',
      tableName: 'users',
      paranoid: true,
      charset: 'utf8',
      collate: 'utf8_general_ci',
    });
  }
  
  static associate(db) {
    db.User.hasMany(db.Record);
  }
};
```



```js
// Record Model

const { DataTypes, Sequelize } = require('sequelize');

module.exports = class Record extends Sequelize.Model {
  static init(sequelize) {
    return super.init({
      date: {
        type: DataTypes.STRING(40),
        allowNull: false,
        validate : {
            date(value) {
                var isDate = RegExp(/^\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/);
                if(isDate.test(value) == false) {
                    throw new Error('다시 날짜를 입력해주세요!');
                }
            }
        },
      },
      etc: {
        type: DataTypes.STRING(300),
        allowNull: true,
      },
      grade: {
        type: DataTypes.INTEGER(40),
        allowNull: false,
        validate: {
            max : 5,
        },
      },
    }, {
      sequelize,
      timestamps: true,
      underscored: false,
      modelName: 'Record',
      tableName: 'records',
      paranoid: true,
      charset: 'utf8',
      collate: 'utf8_general_ci',
    });
  }
  
  static associate(db) {
    db.Record.belongsTo(db.User)
    db.Record.hasMany(db.Image)
  }
};
```



```js
// Image Model

const { DataTypes, Sequelize } = require('sequelize');

module.exports = class Record extends Sequelize.Model {
  static init(sequelize) {
    return super.init({
      date: {
        type: DataTypes.STRING(40),
        allowNull: false,
        validate : {
            date(value) {
                var isDate = RegExp(/^\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$/);
                if(isDate.test(value) == false) {
                    throw new Error('다시 날짜를 입력해주세요!');
                }
            }
        },
      },
      etc: {
        type: DataTypes.STRING(300),
        allowNull: true,
      },
      grade: {
        type: DataTypes.INTEGER(40),
        allowNull: false,
        validate: {
            max : 5,
        },
      },
    }, {
      sequelize,
      timestamps: true,
      underscored: false,
      modelName: 'Record',
      tableName: 'records',
      paranoid: true,
      charset: 'utf8',
      collate: 'utf8_general_ci',
    });
  }
  
  static associate(db) {
    db.Record.belongsTo(db.User)
    db.Record.hasMany(db.Image)
  }
};
```



작성한 Model은 위와 같다.

기존에 작성한 Model과 이번에 작성한 Model의 차이점은 `validate` 옵션을 사용했다는 것이다.



프로젝트를 하기전에는 `validate` 와 같은 옵션을 신경쓰지 않았다. 

왜냐하면 사용자가 본인 하나이기 때문에 항상 형식에 맞는 데이터를 제공하기 때문이다.

하지만 프로젝트의 경우 형식의 맞지 않는 데이터를 받을 가능성을 생각하여야 하기 때문에 `validate` 를 사용하여 이를 대비하였다.



그래서 위와 같은 Model들은 기존의 `models/index.js`  파일에 다음과 같은 코드를 추가하여 설정해 주었다.

```js
// Sequelize adds a getter & a setter for each attribute defined through Model.init
User.init(sequelize);
Record.init(sequelize);
Image.init(sequelize);


User.associate(db);
Record.associate(db);
Image.associate(db);
```



이제 sequelize를 app.js에 등록해 주어야 한다.

```js
/* app.js */

sequelize = require('../DB/sequelize/models').sequelize;

sequelize.sync();
```



위의 코드와 같이 app.js에 등록하는 방법은 간단하다.

위와 같이 등록을 하게 되면 서버가 app.js 를 실행할 때마다 sequelize는 DB와 `.sync()`를 수행하여 sequelize 를 통해 정의한 Model 및 설정이 DB와 맞는지 확인하고 다른 것이 있다면 수정해 준다.



### sequelize-cli

---

위와 같이 Model을 생성한 이후 sequelize-cli를 사용해보았다.

sequelize가 서버가 실행된 상태에서 요청에 따라 DB를 조작하는거라면 sequelize-cli는 서버가 실행되지 않은 상태에서도 DB를 조작할 수 있다.

그렇기에 Day1에서 서버 동작 여부와 상관없이 정보가 들어있는 config.json 파일은 sequelize-cli가 사용가능하지만 서버가 동작해야 정보가 입력되는 config.js 파일은 sequelize-cli가 사용할 수 없는 것이다. 



sequelize-cli는 테이블의 데이터 추가 및 삭제는 물론 테이블, 칼럼의 조건 수정과 같은 동작을 수행할 수 있다.



migration을 통해 다음과 같이 컬럼을 삭제할 수 있고

```js
module.exports = {
    up: (queryInterface, Sequelize) => {
        return queryInterface.sequelize.transaction(t => {
            return Promise.all([
              queryInterface.removeColumn('records', 'img', { transaction: t }),
            ]);
          });
    },
    down: (queryInterface, Sequelize) => {
        
      }
  };
```



seeder을 통해 다음과 같이 초기 데이터를 생성할 수 있다.

```js
/* seeders/User.js */

'use strict';

module.exports = {
  async up (queryInterface, Sequelize) {
     await queryInterface.bulkInsert('users', [{
      name : "김종준",
      sex : "m",
      cycle : 7,
      createdAt: new Date(),
      updatedAt: new Date(),
     },{
      name : "나혜연",
      sex : "w",
      cycle : 7,
      createdAt: new Date(),
      updatedAt: new Date(),
     },{
      name : "나인혜",
      sex : "w",
      cycle : 7,
      createdAt: new Date(),
      updatedAt: new Date(),
     }],);
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.bulkDelete('users', null, {});
  }
};
```

```js
/* seeders/Record.js */

'use strict';
var User = require('../models/User');

module.exports = {
  async up (queryInterface, Sequelize) {;
    async function  findId( userName ) {
      var id = await queryInterface.rawSelect('users', {
        where: {
          name: userName,
        },
      }, ['id']);
      return id;
    }
    await queryInterface.bulkInsert('records', [{
      date : "1999-03-04",
      etc : null,
      grade : 5,
      UserId : await findId("김종준"),
      createdAt: new Date(),
      updatedAt: new Date(),
     },{
      date : "2001-07-25",
      etc : null,
      grade : 5,
      UserId : await findId("나인혜"),
      createdAt: new Date(),
      updatedAt: new Date(),
     },{
      date : "2002-09-04",
      etc : null,
      grade : 5,
      UserId : await findId("나혜연"),
      createdAt: new Date(),
      updatedAt: new Date(),
     }], {});
  },

  async down (queryInterface, Sequelize) {
    await queryInterface.bulkDelete('records', null, {});

  }
};
```



위의 seeder 파일 중 `Record.js` 의 경우 위와 같이 설정하는 것에 고생을 조금하였다.

Record Model의 경우 User Model 과 연관관계에 있다. 

그렇기에 처음에는 기존의 방법처럼 `User.findOne()` 을 활용하여 UserId를 설정해 주려하였다.

하지만 sequelize-cli는 서버가 동작하지 않는 상태에서 동작하기 때문에 `User.findOne()` 과 같은 서버가 동작할 때 사용할 수 있는 방법을 사용하지 못한다.

그렇기에 서버가 동작하지 않는 상태에서도 동작하는 방법이 필요하였고 그 방법이  위의 `queryInterface.rawSelect` 이다.



![Hairlog_day2_config](C:\Users\User\Desktop\Study\TIL\image\Hairlog_day2_config.JPG)

그리고 본인의 경우 config 파일을 위의 사진과 같이  `.js` 그리고 `.json` 으로 2가지로 만들었기 때문에 sequelize-cli를 실행하는 것에도 추가적인 옵션이 필요하였다.

원래 기본적인 실행 방법은 다음과 같다.

```
npx sequelize-cli db:migrate
```



하지만 본인의 경우 다음과 같이 config 옵션을 추가해주어야 했다.

```
npx sequelize-cli db:migrate --config config/config.json
```



sequelize-cli가 기본적으로 config 파일을 인지하기 때문에 config 옵션을 config/config.json 과 같이 설정할 수 있는 것이다.
