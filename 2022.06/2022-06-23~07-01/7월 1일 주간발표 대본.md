제가 이번에 발표할 내용은 비동기 처리에 관한 내용입니다.

보이는 사진은 동기와 비동기에 관해 잘나태내준 사진입니다.

동기의 경우 보이시는 것처럼 파랑 빨강 노랑 순으로 실행될 것입니다.

만약 파랑에서의 실행할 결과를 처리해야 한다면 빨강에 그 결과를 처리할 함수를 넣어 해결할 수 있을 것입니다.

그렇다면 비동기의 경우를 볼까요?

파랑 빨강 노랑이 비슷한 순간에 실행이 됩니다.

만약 빨강의 실행 결과를 처리해야 한다면 어떻게 해야할까요?

이를 위해 콜백함수라는 것이 존재합니다.

우선 콜백함수는 코드를 통해 명시적으로 호출하는 함수가 아닙니다.

개발자는 단지 함수를 등록하기만 하고, 어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출하는 함수를 말한다.

어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 라는 말은 콜백 함수가 비동기적 실행의 결과를 처리할 수 있다는 것을 뜻합니다.

옆에 보이는 예시처럼 파랑 빨강 노랑이 비슷한 순간에 시작되지만 끝나는 순간이 다르도록 코드를 작성하였습니다.

결과 역시 red yellow blue로 예시의 끝나는 순서대로 기록되었습니다.

만약 빨강의 결과를 바꾸고 싶을 때는 어떻게 할까요?

이때 콜백 함수가 사용됩니다.

다음은 이를 반영한 코드인데 setTimeout이 끝나면 콜백함수는 red를 매개변수로 받고

콜백함수인 printString은 매개변수로 받은 red를 빨강으로 바꾸고 출력합니다.

그렇기에 아래와 같은 결과가 나오게 되는 것입니다.

콜백함수를 통해 비동기적으로 실행한 함수의 결과를 처리한 것입니다.

이처럼 콜백함수는 그 자체로 비동기 함수는 아니지만 비동기 함수가 만든 결과를 처리 할 수 있는 함수입니다.

다시 예제로 돌아와서 파랑 빨강 노랑이 모두 실행된 이후에 이들을 더 진한 파랑 더 진한 빨강 더 진한 노랑과 같이 바꾸고 싶으면 어떻게 할까요? 이럴 때 사용되는 것이 Promise.all입니다.

Promise.all은 Promise의 정적 메서드이기 때문에 우선 Promise에 대해 알아봅시다.

Promise는 생성된 시점에는 알려지지 않았을 수도 있는 값을 위한 것으로 최종 결과를 반환하는 것이 아니고, 미래의 어떤 시점에서 결과를 제공하겠다는 '**약속**'을 반환한다고 합니다.

코드로 살펴보면 정말로 Promise 라는 약속을 반환하는 것을 볼 수 있습니다.

물론 최종 결과를 반환 받는 것도 가능합니다.

다음 그림을 보면 Promise는 처음에 이행하지도, 거부하지도 않은 초기 상태인 pending 상태로 있습니다.

그리고 Promise 속 코드들이 정상적으로 수행된다면 fullfill상태 그렇지 않다면 reject 상태가 되게 됩니다.

우리가 원하는 최종 결과를 얻기 위해서는 promise가 fullfill 상태이어야 하고 이때 then 메서드 속에서 그 결과를 얻을 수 있습니다.

이제 promise.all 입니다.

이는 정적 메서드로 순회 가능한 객체에 주어진 모든 프로미스가 이행되는 것을 기다리거나 어느 하나가 거부되기를 기다립니다.

아래는 Mdn에서 가져온 예시 코드인데 promise.all은 promise1,2,3를 한번에 실행시키고 그것이 이행될 때 까지 기다리다 결과를 반환해 줍니다.

제가 이번 프로젝트를 하면서 많이 사용한 것 역시 promise.all 이었는데 다음과 같이 사용하였습니다.

이 코드는 많은 기록들 중에서 그 기록과 관련된 이미지를 가져오는 코드입니다.

promise.all과 map을 활용하여 기록에 따른 이미지를 찾는 것을 비동기적으로 요청할 수 있었습니다.

문제는 다음 코드였습니다.

저는 이미지를 올리고 리사이징해서 클라우드에 업로드 하고싶었는데

옆의 코드를 통해서는 리사이징과정이 끝나지 않았는데도 클라우드에 업로드 되는 문제가 발생하였습니다.

저는 처음에 promise.all 과 map을 통해 비동기 함수를 만들었고 그것을 처리할 콜백함수까지 있으니 제가 원하는

위와 같은 구현이 가능할 것이라 생각했습니다.

하지만 제가 놓인 것이 있었습니다. 

콜백함수가 비동기 결과를 처리할 수는 있지만 그 순서가 비동기 결과 후라는 보장을 하지는 않는다는 것입니다.

다음은 자바스크립트 엔진의 구조입니다.

간단히 말해서 제가 무언가를 실행할 때 명령들이 callstack에 쌓이고 이때 콜백함수의 경우 callback que 에 있게 됩니다.

특정 경우가 되었을 때 callback que의 명령은 eventloop를 통해 callstack으로 돌아오게되는데 이때 callstack에는 아무런 것도 없어야 한다고 합니다.

그렇기에 저의 프로젝트도 리사이징 이후 클라우드에 올리는 과정이 없었다면 저는 아무런 문제가 없다고 생각했을 것입니다.

리사이징 명령이후에 callbackque에 있는 콜백삼수가 바로 callstack에 올라갔을 것이기 때문입니다.

하지만 저의 프로젝트는 클라우드에 올리는 과정이 있고 이때문에 callbackque의 콜백함수는 리사이징 이후 바로 callstack으로 가지 못하게된 것입니다.

이러한 문제를 해결하기 위해서는 앞서 설명한 promise의 then을 이용하여 순서를 보장해줄 필요가 있었고 다음과 같이 순서를 보장한 이후에는 리사이징된 것들이 클라우드에 올라가게 되엇습니다.

제가 이 발표를 통해 전하고싶은 것은 두가지였던것 같습니다.

첫번째는 아무래도 비동기가 자바스크립트에서는 어느정도 난이도가 있는 개념이기 때문에 아직 완벽하지는 않지만 저는 어떻게 이해하고 있나 공유하고 싶었습니다.

그리고 두번째는 고마움입니다.

저의 멘토 채승님부터 시작해서 이번 문제를 해결하는데 도움을 준 윤성님, 현지님 그리고 항상 모르고 궁금한 것이 있으면 도와주시는 많은 에코노 분들 덕분에 항상 감사하며 지내고 있다는 것을 전달하고 싶었습니다. 

 