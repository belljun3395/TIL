# 2022-04-26

### Today I Learned

- JAVA의 정석

#### 상속

---

상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.

자바에서의 상속은 새로 작성하고자 하는 클래스의 이름 뒤에 상속 받고자 하는 클래스의 이름을 `extends` 와 함께 써 주는 것이다.

```java
class Child extends Parent {
	//...
}
```



자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.

즉, 상속에서 상속을 거듭할수록 상속받는 클래스의 멤버 개수는 점점 늘어나게 되는 것이다.

그런 점에서 본인은 상속이라는 한국어보다 `extends` 라는 영어가 그 의미를 더 잘 전달한다 생각한다.

​	

> **상속**
>
> ---
>
> -  생성자와 초기화 블록은 상속되지 않는다. 멤버만 상속된다.
> - 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.
>
> 
>
> \* 하나의 Parent 가 Child1, Child2에게 상속을 하여도 Child1과 Child2는 서로 관계가 없다.
> 	클래스 간의 관계에서 형제 관계와 같은 것은 없다!



#### 포함

---

포함은 상속이외의 클래스를 재사용하는 또 다른 방법이다. 

클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

```java
class Circle {
    int x;
    int y;
    int r;
}

class Point {
    int x;
    int y;
}

class Circle {
    Point c = new Point ();
    int r;
}
```



##### 클래스간의 관계 결정하기

---

> **상속 관계**  :  '~은 ~이다.( is ~ a )'
>
> **포함 관계**  :  '~은 ~을 가지고 있다.( has ~ a )' 



#### 오버라이딩

---

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라 한다.

상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경하는 경우가 많다.

이럴 때 조상의 메서드를 오버라이딩한다.



##### 오버라이딩의 조건

---

오버라이딩은 메서드의 내용만을 새로 작성하는 것으로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.

그래서 오버라이딩이 성립하기 위한 조건은 다음과 같다.

> 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
>
> - 이름이 같아야 한다.
> - 매개변수가 같아야 한다.
> - 반환타입이 같아야 한다.



다만 접근 제어자와 예외는 제한 조건 하에서만 다르게 변경할 수 있다.

1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.



##### 오버로딩 vs 오버라이딩

---

> **오버로딩**  :  기존에 없는 새로운 메서드를 정의하는 것
>
> **오버라이딩**  :  상속받은 메서드의 내용을 변경하는 것



```java
class Parent {
    void parentMethod(int i) {}
}

class Child extends Parent {
    void parentMethod(int i) { // 동작방법 변경 } // 오버라이딩 
    void parentMethod(long l // 파라미터 변경) {} // 오버로딩
}
```



#### super

---

super은 자손 클래스에서 조상 클래스로 부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다.

조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점으 제외하고는 super와 this는 근본적으로 같다.

모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 된다.

static 메서드는 인스턴스와 관련이 없다. 

그래서 this와 마찬가지로 super 역시 static 메서드에서는 사용할 수 없고 인스턴스메서드에서만 사용할 수 있다.



##### `super() `

---

this()와 마찬가지로 super() 역시 생성자이다. 

this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()은 조상 클래스의 생성자를 호출하는데 사용된다.



자손 클래스의 인스턴스르 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 

그래서 자손의 클래스를 사용할 때 조상의 클래스 멤버들을 사용할 수 있는 것이다.

이 때 조상의 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.



생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상 멤버들이 먼저 초기화되어 있어야 하기 때문이다.



Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자(this() 또는 super())를 호출해야 한다.

그렇지 않으면 컴파일러가 자동적으로 super()를 생성자의 첫 줄에 삽입한다.



#### 제어자

---

제어자는 클래스, 변수 또는 메서드의 선언부에 함게 사용되어 부가적인 의미를 부여한다.

제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.



> 접근 제어자 :  public, protected, default, private
>
> 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp



제어자는 클래스나 멤버변수와 메서드에 주로 사용되며, 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.



접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역활을 한다.

접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지 않는다. 

클래스나 멤버변수, 메서드, 생성자에 접근 제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻한다.



> 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
>
> private - 같은 클래스 내에서만 접근이 가능하다.
>
> default - 같은 패키지 내에서만 접근이 가능하다.
>
> protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
>
> public - 접근 제한이 전혀 없다.



접근 제어자를 사용하는 이유

- 외부로부터 데이터르 보호하기 위해서 
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서



##### 생성자의 접근 제어자

---

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.

보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수도 있다.

생성자의 접근 제어자를 private으로 지정하면, 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없게 된다. 

그래도 클래스 내부에서는 인스턴스의 생성이 가능하다.

이는 **singleton**을 위한 것이다.

```java
class Singleton {
    // ...
    private static Singleton s = new Singleton();
    private Singelton () {
        // ...
    };
    public static Singleton getInstanace() {
        return s;
    };
};
```

이처럼 생성자를 통해 직접 인스턴스르 생성하지 못하게 하고 public 메서드르 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스 개수를 제한할 수 있다.



이때 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다. 

자손클래스의 인스턴스르 생성할 때 조상클래스의 생성자를 호출해야 하는데, 생성자의 접근 제어자가 private이므로 자손클래스에서 호출하는 것이 불가능하기 때문이다.

그래서 클래스 앞에 final을 추가하여 상속할 수 없는 클래스라는 것을 알리는 것이 좋다.



##### 제어자의 조합

---

1. 메서드에 static과 abstract를 함께 사용할 수 없다.
   - static 메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문이다.
2. 클레스에 abstract와 final을 동시에 사용할 수 없다.
   - 클래스에 사용되는 final 클래스는 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
3. abstract  메서드의 접근 제어자가 private일 수 없다.
   - abstract 메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문이다.
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
   - 접근 제어자가 private인 메서드는 오버라이딩이될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.



#### 다형성

---

다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다향성을 프로그램적으로 구현하였다.

즉 조상클래스 타입의 참조변수(Tv)로 자손 클래스의 인스턴스(`new CaptioTV()`)를 참조할 수 있도록 하였다는 것이다.

```java
class Tv {
    boolean power;
    int channel;
    
    void power () { power = !power;}
    void channelUp() { ++channel;}
    void channelDonw() { --channel;}
   
}

class CaptionTv extends Tv {
    String text;
    void caption() {}
}

Tv t = new tv();
CaptionTv c = new CatpionTv();
```



이처럼 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 보통이지만, Tv와 CaptionTv 클래스가 서로 상속관계에 있을 경우, 다음과 같이 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능하다.

```java
Tv t = new CaptionTv();
```



이제 인스턴스를 같은 타입의 참조변수로 참조하는 것과 조상 타입의 참조변수로 참조하는 것은 어떤 차이가 있는지에 대해서 알아보자.

```java
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();
```

이 경우 실제 인스턴스가 CaptionTv 타입이라 할지라도, 참조변수 t로는 CaptionTv 인스턴스의 모든 멤버를 사용할 수는 없다.

Tv 타입의 참조변수로는 CaptionTv 인스턴스 중에서 Tv클래스의 멤버들만 사용할 수 있다.

둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.



그렇기에 자손타입의 참조변수(`CaptionTv c`)로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용하지 않는 것이다.

참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.

참조변수의 타입이 참조변수가 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 결정한다는 사실을 이해하는 것은 매우 중요하다.



> 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
>
> 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.



##### 참조변수의 형변환

---

기본형 변수와 같이 참조변수도 형변환이 가능하다. 단, 서로 상속관계에 있는 클래스 사이에서만 가능하기 때문에 자손타입의 참조변수를 조상타입의 참보변수로, 조상타입의 참조변수를 자손타입의 참조변수로 형변환만 가능하다.

이때 기본형의 형변환에서 작은 자료형에서 큰 자료형의 형변환은 생략이 가능하듯이, 참조형 변수의 형변환에서는 자손타입의 참조변수를 조상타입으로 형변환하는 경우에는 형변환을 생략할 수 있다.



> 자손타입  => 조상타입 (Up-casting) : 형변환 생략가능
>
> 자손타입 <= 조상타입 (Down-casting) : 형변환 생략불가
>
> \* 본인은 위와 같은 이유가 참조할 수 있는 인스턴스 멤버의 개수 차이 때문이라 생각한다.
> 	자손타입이 조상타입보다 그 수가 많기에 형변환 생략이 가능하지만 반대의 경우 자손타입에서 조상타입	없는 멤버를 처리해야 하기에 형변환을 생략 불가하다 생각한다.



##### `instanceof` 연산자

---

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 `instanceof `연산자를 사용한다.

`instanaceof`는 연산의 결과로 boolean값 true와 false 중의 하나를 반환한다.

조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있기 때문에, 참조변수의 타입과 인스턴스의 타입이 항상 일치하지 않는다는 것을 알았다.

조상타입의 참조변수로는 실제 인스턴스의 멤버들 모두 사용할 수 없기 때문에, 실제 인스턴스와 같은 타입의 참조변수로 형변환을 해야만 인스턴스의 모든 멤버들을 사용할 수 있다.



##### 참조변수와 인스턴스의 연결

---

조상 타입의 참조변수와 자손 타입의 참조변수의 차이점이 사용할 수 있는 멤버의 개수에 있다고 배웠다. 

그런데 조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때, 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우 서로 다른 결과를 얻는다.

즉 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용 했을 때는 자손 클래스에 선언된 멤버변수가 사용된다. 



#### Vector 클래스

---

Vector 클래스는 내부적으로 Object 타입의 배열을 가지고 있어서, 이 배열에 객체를 추가하거나 제거할 수 있게 작성되어 있다.

그리고 배열의 크기를 알아서 관리해주기 때문에 저장할 인스턴스의 개수에 신경 쓰지 않아도 된다.

즉 Vector 클래스는 동적으로 크기가 관리되는 객체배열이다.

Vector 클래스의 메소드로는 다음과 같은 것이 있다.

- `new Vector()` : 10개의 객체를 저장할 수 있는 Vector 인스턴스를 생성한다. 10개 이상이 되면 자동적으로 크기가 증가 된다.
- `add` : Vector에 객체를 추가한다.
- `remove` : Vector에 저장되어 있는 객체를 제거한다.
- `isEmpty`: Vector가 비어있는지 검사한다.
- `get` : 지정된 위치의 객체를 반환한다. 반환타입이 Object 타입이므로 적절한 타입으로 형변환이 필요하다.
- `size` : Vector에 저장된 객체의 개수를 반환한다.



#### 추상클래스

---

추상 클래스는 미완성이 클래스이다.

클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드를 포함하고 있다는 것이다.

추상클래스 자체로는 클래스로서의 역할을 다 못하지만, 새로운 클래스를 작성하는데 있어서 바탕이 되는 조상클래스로서 중요한 의미를 갖는다.

추상클래스는 키워드 abstract를 붙이기만 하면 된다.

이렇게 함으로써 이 클래스를 사용할 때, 클래스 선언부의 abstract를 보고 이 클래스에는 추상메서드가 있으니 상속을 통해 구현해주어야 한다는 것을 쉽게 알 수 있다.



메서드를 이와 같이 미완성 상태로 남겨 놓는 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는 선언부만 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성되었는지 알려 주고, 실제 내용은 상속받는  클래스에서 구현하도록 비워두는 것이다. 그래서 추상클래스를 상속받는 자손 클래스는 조상의 추상메서드를 상황에 맞게 적절히 구현해주어야 한다.



```java
// 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다.
abstract 리턴타입 메서드이름();
```

```java
abstract class Player {
    abstract void play (int pos);
    abstract void stop();
    void start () {
        // 음악 시작
    }
}

class AudioPlayer extends Player {
    void play(int pos) { ... } // 추상메서드를 구현
    void stop() { ... } // 추상메서드를 구현
}
```

실제 작업내용인 구현부가 없는 메서드가 무슨 의미가 있을까 하겠지만, 메서드를 작성할 때 실제 작업내용인 구현부보다 더 중요한 부분이 선언부라 한다.

메서드의 이름과 메서드의 작업에 필요한 매개변수, 그리고 작업의 결과로 어떤 타입의 값을 반환할 것인가를 결정하는 것은 쉽지 않은 일이다.

메서드를 사용하는 쪽에서는 메서드가 실제로 어떻게 구현되어있는지 몰라도 메서드의 이름과 매개변수, 리턴타입, 즉 선언부만 알고 있으면 되므로 내용이 없을 지라도 추상메서드를 사용하는 코드를 작성하는 것이 가능하며, 실제로는 자손클래스에 구현된 완성된 메서드가 호출되도록 할 수 있다.



##### 추상화

---

상속이 자손 클래스를 만드는데 조상 클래스를 사용하는 것이라면, 이와 반대로 추상화는 기존의 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것이라고 할 수 있다.

추상화를 구체화와 반대되는 의미로 이해하면 보다 쉽게 이해할 수 있다. 

상속계층도를 따라 내려갈수록 클래스는 점점 기능이 추가되어 구체화의 정도가 심해지며, 상속 계층도를 따라 올라갈수록 클래스는 추상화의 정도가 심해진다고 할 수 있다.



#### 인터페이스

---

인터페이스는 일종의 추상클래스이다. 

인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.

오직 추상메서드(`abstract`)와 상수(`static final`)만을 멤버로 가질 수 있으며, 그 외의 다른 어떤 요소도 허용하지 않는다.



인터페이스를 작성하는 것은 클래스를 작성하는 것과 같다. 다만 키워드로 class 대신 interface를 사용한다는 것만 다르다.

그리고 interface에도 클래스와 같이 접근제어자로 public 또는 default를 사용할 수 있다.

```java
interface 인터페이스 이름 {
    public static final 타입 상수이름 = 값;
    pulbic abstract 메서드이름(매개변수목록);
}
```



일반적인 클래스의 멤버들과 달리 인터페이스의 멤버들은 다음과 같은 제약사항이 있다.

- 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다.
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
  단, static 메서드와 default 메서드는 예외



인터페이슨느 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.



인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 추상클래스가 상속을 통해 추상메서드를 완성하는 것처럼, 인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 하는데, 그 방법은 추상클래스가 자신을 상속받는 클래스를 정의하는 것과 다르지 않다.

다만 클래스는 확장한다는 의미의 `extends`를 사용하지만 인터페이스는 구현한다는 의미의 `implements`를 사용한다.

```java
class a implements i {
    // ...
}
```

인터페이스 역시 이를 구현한 클래스의 조상이라 할 수 있으로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다.



인터페이스 Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter 인스턴스르 Fightable 타입의 참조변수로 참조하는 것이 가능하다.

```java
Fightable f = (Fightable) new Fighter();
// or
Fightable f = new Fighter();
```



따라서 인터페이스는 다음과 같이 메서드의 매개변수의 타입으로도 사용될 수 있다.

```java
void attack (Fightable f) {
    // ...
}
```



메서드의 리턴타입으로 인터페이스의 타입을 지정하는 것 역시 가능하다.

```java
Fightable method() {
	// ...
	Fighter f = new Fighter();
	return f;
}
```

리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.



즉 위의 예제를 보면 method()의 리턴타입이 Fightable 인터페이스이기 때문에 메서드의 return 문에서 Fightable 인터페이스를 구현한 Fighter 클래스의 인터페이스를 반환한다.



##### 인터페이스의 장점 

- 개발 시간을 단축시킬 수 있다.
  인터페이스가 작성되면, 이를 사용해서 프로그램을 작성하는 것이 가능하다. 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문이다.
  그리고 동시에 다른 한 쪽에서는 인터페이스르 구현하는 클래스를 작성하도록 하여, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다.
- 표준화가 가능하다
  프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램 개발이 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
  서로 상속관계에 있지 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스르 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍이 가능하다.
  인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다. 클래스와 클래스간의 직접적인 관계를 인터페이스를 이요해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.



사실 위와 같이 인터페이스에 관하여 알아보았지만 인터페이스가 무엇인지에 관한 의문은 여전하다.

먼저 인터페이스를 이해하기 위해서는 다음의 두 가지 사항을 반드시 염두해 두고 있어야 한다.

- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다.
- 메서드를 사용(호출) 하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.



#### 내부 클래스

---

내부 클래스는 클래스 내에 선언된 클래스이다.

클래스에 다른 클래스 선언하는 이유는 간단하다. 두 클래스가 서로 긴밀한 관계에 있기 때문이다.

한 클래스를 다른 클래스의 내부 클래스로 선언하면 두 클래스의 멤버들 간에 서로 쉽게 접근할 수 있다는 장점과 외부에는 불필요한 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점이 있다.



내부 클래스의 종류는 변수의 선언위치에 따른 종류와 같다.

내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언할 수 있으며, 변수의 선언위치에 따라 인스턴스변수, 클래스변수(static 변수), 지역변수로 구분되는 것과 같이 내부 클래스도 선언위치에 구분된다.

내부 클래스의 유효범위와 성질은 변수와 유사하다.



##### 내부 클래스의 종류

- 인스턴스 클래스 
  외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. 주로 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.
- 스태틱 클래스
   외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static 멤버처럼 다루어진다. 주로 외부 클래스의 static 멤버, 특히 static 메서드에서 사용될 목적으로 선언된다.
- 지역 클래스
  외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.
- 익명 클래스
  클래스의 선언과 객체의 생성을 동시에 하는 이름 없는 클래스로 일회용이다.





